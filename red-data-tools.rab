= Red Data Tools

: subtitle
   æ¥½ã—ãå®Ÿè£…ã™ã‚Œã°ã„ã„ã˜ã‚ƒã‚“ã­ãƒ¼
: author
   é ˆè—¤åŠŸå¹³
: institution
   æ ªå¼ä¼šç¤¾ã‚¯ãƒªã‚¢ã‚³ãƒ¼ãƒ‰
: content-source
   æ²–ç¸„Rubyä¼šè­°02
: date
   2018-03-10
: start-time
   2018-03-10T13:00:00+09:00
: end-time
   2018-03-10T13:50:00+09:00
: theme
   clear-code

= Red Data Tools

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ

= å®Ÿç¾ã—ãŸã„ã“ã¨

Rubyã§\n
ãƒ‡ãƒ¼ã‚¿å‡¦ç†

= ã‚„ã£ã¦ã„ã‚‹ã“ã¨

ãƒ‡ãƒ¼ã‚¿å‡¦ç†ç”¨ã®\n
ãƒ„ãƒ¼ãƒ«ã®é–‹ç™º

= é–‹ç™ºä¾‹

  * å„ç¨®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’æ‰±ã†gem
    * Apache Arrow, Apache Parquet, CSV, ...
  * å„ç¨®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ç”¨æ„
    * deb, RPM, Homebrew, ...
  * ...

= ã“ã®è©±ã®ç›®çš„

å‹§èª˜\n
(('note:ä¸€ç·’ã«é–‹ç™ºã—ã‚ˆã†ãœï¼'))

= å‹§èª˜æ–¹æ³•

  * ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒãƒªã‚·ãƒ¼ã‚’ç´¹ä»‹
    * ä¸€ç·’ã«æ´»å‹•ã—ãŸããªã‚‹ï¼
  * é–‹ç™ºã®å…·ä½“ä¾‹ã‚’ç´¹ä»‹
    * ä¸€ç·’ã«é–‹ç™ºã—ãŸããªã‚‹ï¼

= ãƒãƒªã‚·ãƒ¼1

(('tag:center'))
(('tag:large'))
Rubyã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãƒ¼ã‚’\n
è¶…ãˆã¦å”åŠ›ã™ã‚‹\n
(('note:ã‚‚ã¡ã‚ã‚“Rubyã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãƒ¼ã¨ã‚‚å”åŠ›ã™ã‚‹'))

== ã‚¹ãƒ©ã‚¤ãƒ‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ¼

: as-large-as-possible
   false

= Rubyã«é–‰ã˜ãšã«å”åŠ›

  * ä»–ã®è¨€èªã¯æ•µã§ã¯ãªã„
    * ä»–ã®è¨€èªãŒã‚ˆããªã‚‹ã“ã¨ã¯\n
      RubyãŒãªã«ã‹ã‚’å¤±ã†ã“ã¨ã§ã¯ãªã„
  * ã¿ã‚“ãªã‚ˆããªã£ãŸã‚‰ã„ã„ã˜ã‚ƒã‚“
    * Rubyã‚‚ä»–ã®è¨€èªã‚‚

= å”åŠ›ä¾‹\n(('note:Apache Arrow'))

  * Pythonã®äººé”ä»–ã¨ä¸€ç·’ã«C/C++ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚’é–‹ç™º
    * ãã‚Œãã‚Œã§ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’é–‹ç™º
    * ãã‚Œãã‚Œã§åŒã˜ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚’æ´»ç”¨

= ãƒãƒªã‚·ãƒ¼2

(('tag:center'))
(('tag:large'))
éé›£ã™ã‚‹ã“ã¨ã‚ˆã‚Šã‚‚\n
æ‰‹ã‚’å‹•ã‹ã™ã“ã¨ãŒå¤§äº‹

== ã‚¹ãƒ©ã‚¤ãƒ‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ¼

: as-large-as-possible
   false

= éé›£ã—ãªã„

ãã‚“ãªã“ã¨ã‚’\n
ã—ã¦ã„ã‚‹\n
æ™‚é–“ã¯ãªã„

= æ‰‹ã‚’å‹•ã‹ã™

  * ã“ã‚Œã€ã‚ˆããªã„ãªãƒ¼
    * ã‚ˆãã™ã‚Œã°ã„ã„ã˜ã‚ƒã‚“ã­ãƒ¼
  * ã“ã‚ŒãŒãªã„ã‹ã‚‰ãªãƒ¼
    * ä½œã‚Œã°ã„ã„ã˜ã‚ƒã‚“ã­ãƒ¼

= ãƒãƒªã‚·ãƒ¼3

(('tag:center'))
(('tag:large'))
ä¸€å›ã ã‘ã®æ´»ç™ºãªæ´»å‹•ã‚ˆã‚Š\n
å°ã•ãã¦ã‚‚\n
ç¶™ç¶šçš„ã«æ´»å‹•ã™ã‚‹ã“ã¨ãŒ\n
å¤§äº‹

== ã‚¹ãƒ©ã‚¤ãƒ‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ¼

: as-large-as-possible
   false

= ä¸€å›ã ã‘ã®æ´»ç™ºãªæ´»å‹•

  * â—‹â—‹ä½œã£ãŸã‚ˆï¼ã©ãƒ¼ã‚“ï¼
    * ã™ã”ã„ï¼
    * (('note:â€¦æ•°å¹´å¾Œâ€¦'))ä»Šå‹•ã‹ãªã„ã‚“ã ã‚ˆã­â€¦

= ç¶™ç¶šçš„ãªæ´»å‹•

  * ã¡ã¾ã¡ã¾â—‹â—‹ä½œã£ã¦ã‚‹ã‚“ã ãƒ¼ï¼
    * ãŒã‚“ã°ã£ã¦ã­ï¼ä»Šå¾Œã«æœŸå¾…ï¼
    * (('note:â€¦æ•°å¹´å¾Œâ€¦'))ã“ã‚Œã¯â€¦ä½¿ãˆã‚‹ï¼

= ç¶™ç¶šçš„ãªæ´»å‹•ã®ãŸã‚ã«

  * ãŒã‚“ã°ã‚Šéããªã„
    * çŸ­è·é›¢èµ°ã§ã¯ãªããƒãƒ©ã‚½ãƒ³
    * é€”ä¸­ã§ä¼‘ã‚“ã ã£ã¦ã„ã„
  * 1äººã§æŠ±ãˆè¾¼ã¾ãªã„
    * ã¿ã‚“ãªã§ã‚„ã‚Œã°é€”ä¸­ã§ä¼‘ã¿ã‚„ã™ã„

= ãƒãƒªã‚·ãƒ¼4

(('tag:center'))
(('tag:large'))
ç¾æ™‚ç‚¹ã§ã®çŸ¥è­˜ä¸è¶³ã¯\n
å•é¡Œã§ã¯ãªã„

== ã‚¹ãƒ©ã‚¤ãƒ‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ¼

: as-large-as-possible
   false

= çŸ¥è­˜ä¸è¶³ï¼Ÿ

  * é«˜é€Ÿãªå®Ÿè£…ã®å®Ÿç¾
    * ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ãƒ»æ•°å­¦ãªã©ã®\n
      é«˜åº¦ãªçŸ¥è­˜ã¯ä¾¿åˆ©
  * ä»Šã™ã”ã„äººã§ã‚‚\n
    æœ€åˆã¯ãªã«ã‚‚çŸ¥ã‚‰ãªã‹ã£ãŸ
    * ã€Œä»ŠçŸ¥ã‚‰ãªã„ã“ã¨ã€ã¯\n
      ã€Œå§‹ã‚ãªã„ç†ç”±ã€ã«ã¯ãªã‚‰ãªã„

= ç§ãŸã¡ã¯å­¦ã¹ã‚‹

  * çŸ¥è­˜ã¯èº«ã«ã¤ã
    * æ´»å‹•ã—ã¦ã„ãä¸­ã§è‡ªç„¶ã¨
  * å­¦ã³æ–¹
    * OSSã®æ—¢å­˜å®Ÿè£…ã‹ã‚‰å­¦ç¿’
    * ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’èª­ã‚€
    * ä»–ã®äººã‹ã‚‰æ•™ãˆã¦ã‚‚ã‚‰ã†

= ãƒãƒªã‚·ãƒ¼5

(('tag:center'))
(('tag:large'))
éƒ¨å¤–è€…ã‹ã‚‰ã®éé›£ã¯\n
æ°—ã«ã—ãªã„

== ã‚¹ãƒ©ã‚¤ãƒ‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ¼

: as-large-as-possible
   false

= éƒ¨å¤–è€…ã‹ã‚‰ã®éé›£

  * Rubyã§é ‘å¼µã£ã¦ã‚‚ã‚¢ãƒ¬ã ã‚ˆã­ãƒ¼\n
    ã¨ã‹
    * ç„¡è¦–ã™ã‚‹
  * å¯¾å¿œã—ã¦ã„ã‚‹æ™‚é–“ã¯ãªã„

= ãƒãƒªã‚·ãƒ¼6

æ¥½ã—ãã‚„ã‚ã†ï¼

= æ¥½ã—ã‚€

ä½¿ã£ã¦ã„ã‚‹ã®ã¯\n
Rubyã ã‹ã‚‰ï¼

= ãƒãƒªã‚·ãƒ¼

  * Rubyå¤–ã¨ã‚‚å”åŠ›
  * éé›£ã™ã‚‹ã‚ˆã‚Šæ‰‹ã‚’å‹•ã‹ã™
  * ç¶™ç¶šçš„ãªæ´»å‹•
  * çŸ¥è­˜ä¸è¶³ã¯å•é¡Œãªã„
  * å¤–ã‹ã‚‰ã®éé›£ã¯æ°—ã«ã—ãªã„
  * æ¥½ã—ãã‚„ã‚ã†ï¼

= é–‹ç™ºä¾‹

  * ãƒ„ãƒ¼ãƒ«ã®ç´¹ä»‹((*ã§ã¯ãªã„*))
  * å®Ÿè£…ã®ç´¹ä»‹
    * é–‹ç™ºä¸­ã«((*ãŠã£*))ã¨æ€ã£ãŸã‚„ã¤ã¨ã‹
    * ç´¹ä»‹ã—ãŸã„ã‚„ã¤ã¨ã‹

= é–‹ç™ºä¾‹1

csv

= csv

  * CSVã®èª­ã¿æ›¸ããƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼
  * 2003å¹´ã‹ã‚‰æ¨™æº–æ·»ä»˜
  * 2018å¹´ã‹ã‚‰ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ã‚’å¼•å–

= (({dig}))ã‚’è¿½åŠ ã—ãŸã¨ã

(('tag:x-small'))((<URL:https://github.com/ruby/csv/pull/15>))

  * (({CSV::Table#dig}))
  * (({CSV::Row#dig}))

= (({dig}))ã®ä½œã‚Šæ–¹

  # rouge ruby

  def dig(index, *indexes)
    # ã“ã“ã ã‘é•ã†
    value = find_value(index)
    # â†“ã¯å…±é€š
    return nil if value.nil?
    return value if indexes.empty?
    value.dig(*indexes)
  end

= (({CSV::Row}))ã§ã®(({find_value}))

  # rouge ruby

  row[index] # => field value

(({dig}))ã®ä¸­ã§ã¯(({self}))ã®(({[]}))ã‚’å‘¼ã¹ã°ã‚ˆã„

= (({[]}))ã®å‘¼ã³æ–¹

  # rouge ruby

  def dig(index, *indexes)
    # ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã§ã¯
    # selfã‚’çœç•¥ã§ãã‚‹ã‹ã‚‰ã“ã†ï¼Ÿ
    value = [index]
    # â†‘ã¯é…åˆ—ãƒªãƒ†ãƒ©ãƒ«
    # ...
  end

= (({[]}))ã®å‘¼ã³æ–¹

  # rouge ruby

  def dig(index, *indexes)
    # ã“ã†ã„ã†ã¨ãã“ãsendã§ã€€ã€€
    # ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—
    value = send(:[], index)
    # å‹•ã
    # ...
  end

= (({[]}))ã®å‘¼ã³æ–¹

  # rouge ruby

  def dig(index, *indexes)
    # row[index]ã¿ãŸã„ã«æ›¸ã‘ã°ã€€
    # ã‚ˆã‹ã£ãŸ
    value = self[index]
    # ã‚‚ã¡ã‚ã‚“å‹•ã
    # ...
  end

= (({self}))ã®(({[]}))ã®å‘¼ã³æ–¹

  * è‡ªåˆ†ã‚‚æ˜”æ‚©ã‚“ã æ°—ãŒã™ã‚‹
  * æ‡ã‹ã—ã‹ã£ãŸã®ã§ç´¹ä»‹
  * ã¿ã‚“ãªã§é–‹ç™ºğŸ Šæ°—ã¥ãã‚„ã™ã„

= é–‹ç™ºä¾‹2

Red Datasets

= Red Datasets

  * ãƒ‡ãƒ¼ã‚¿ã‚’ç°¡å˜ã«ä½¿ãˆã‚‹ã‚ˆã†ã«ï¼
  * å®Ÿé¨“ãƒ»é–‹ç™ºã«ä¾¿åˆ©

= ä¾‹ï¼šæ—¥æœ¬èªãƒ‡ãƒ¼ã‚¿æ¬²ã—ã„ï¼

  # rouge ruby
  require "datasets"
  # æ—¥æœ¬èªç‰ˆWikipediaã®è¨˜äº‹ãƒ‡ãƒ¼ã‚¿
  options = {language: :ja, type: :articles}
  dataset = Datasets::Wikipedia.new(options)
  dataset.each do |page| # å…¨ãƒšãƒ¼ã‚¸ã‚’é †ã«å‡¦ç†
    p page.title         # ã‚¿ã‚¤ãƒˆãƒ«
    p page.revision.text # æœ¬æ–‡
  end

(('tag:center'))
(('note:ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ãŒeachãªã®ãŒã‚«ãƒƒã‚³ã„ã„ã‚“ã ã‚ˆï¼'))

= å®Ÿè£…æ–¹æ³•

  (1) ãƒ‡ãƒ¼ã‚¿ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
  (2) ãƒ‡ãƒ¼ã‚¿ã®ãƒ‘ãƒ¼ã‚¹
  (3) é †ã«(({yield}))

= ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰

  # rouge ruby
  require "open-uri"
  open("https://...") do |input|
    File.open("...", "wb") do |output|
      IO.copy_stream(input, output)
    end
  end

= é€”ä¸­ã§ã‚¨ãƒ©ãƒ¼ã«ãªã£ãŸã‚‰ï¼Ÿ

(('tag:center'))
(('tag:x-large'))
ã‚„ã‚Šç›´ã—

(('tag:center'))
ã¾ãŸã¯

(('tag:center'))
(('tag:x-large'))
å†é–‹

= å†é–‹

HTTP\n
range request

= HTTP range request

  * ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
    * (({Range: bytes=#{start}-}))
  * ãƒ¬ã‚¹ãƒãƒ³ã‚¹
    * (({206 Partial Content}))
    * (({Content-Range: bytes ...}))

= open-uriã¨range request

  * open-uriã¯range requestæœªå¯¾å¿œ
    * å‡ºåŠ›ç„¡é–¢ä¿‚ã®APIã ã‹ã‚‰ã—ã‚‡ã†ãŒãªã„
  * ã©ã†ãªã‚‹ã®ãŒã„ã„ã ã‚ã†ï¼Ÿ
    * ä»Šåº¦ç”°ä¸­ã•ã‚“ã«ç›¸è«‡ã—ã‚ˆã†
    * Red Data Toolsã¯Rubyã‚‚ã‚ˆãã—ãŸã„\n
      (('note:ãƒãƒªã‚·ãƒ¼1ï¼šã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãƒ¼ã‚’è¶…ãˆã¦å”åŠ›'))

= open-uriã§range request

  # rouge ruby
  # æ–‡å­—åˆ—ã‚­ãƒ¼ã¯HTTPãƒ˜ãƒƒãƒ€ãƒ¼ã«ãªã‚‹
  options = {"Range" => "bytes=#{start}-"}
  open("...", options) do |input|
    # ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒ200ã‹206ã‹ã¯ã‚ã‹ã‚‰ãªã„
    File.open("...", "ab") do |output|
      IO.copy_stream(input, output)
    end
  end

= å¤§ããªãƒ‡ãƒ¼ã‚¿ã®æ‰±ã„

  * æ™‚é–“ãŒã‹ã‹ã‚‹
  * ã‚ã¨ã©ã®ãã‚‰ã„ã‹æ°—ã«ãªã‚‹
    * ã¡ã‚ƒã‚“ã¨å‹•ã„ã¦ã„ã‚‹ã‚ˆã­â€¦ï¼Ÿ

= ã‚ã¨ã©ã®ãã‚‰ã„ï¼Ÿ

ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼

= ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã®å®Ÿè£…

  # rouge ruby

  n = 40
  1.upto(n) do |i|
    print("\r|%-*s|" % [n, "*" * i])
    sleep(0.1)
  end
  puts

= sprintfãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ

(('tag:center'))
(({%-*s}))

  * (({%}))ï¼šãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆé–‹å§‹
  * (({-}))ï¼šå·¦è©°ã‚
  * (({*}))ï¼šå¼•æ•°ã§å¹…ã‚’æŒ‡å®š
  * (({s}))ï¼šå¯¾è±¡ã¯æ–‡å­—åˆ—

= sprintfãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ

(('tag:center'))
(({"%-*s" % [n, "*" * i]}))

  * å¹…ã¯(({n}))æ¡
  * (({"*" * i}))ã‚’å·¦è©°ã‚

= open-uriã§ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼

  # rouge ruby

  length = nil
  progress = lambda do |current|
    ratio = current / length.to_f
    print("\r|%-10s|" % ["*" * (ratio * 10).ceil])
  end
  open(uri,
       content_length_proc: ->(l) {length = l},
       progress_proc: progress) do |input|
    # ...
  end
  puts

= ã‚‚ã£ã¨ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼

  * ãƒãƒƒã‚¯ã‚°ãƒ©ãƒ³ãƒ‰åŒ–ã—ãŸã‚‰ï¼Ÿ
    * è¡¨ç¤ºã—ã¦æ¬²ã—ããªã„\n
      (('note:ãƒ’ãƒ³ãƒˆï¼šãƒ—ãƒ­ã‚»ã‚¹ã‚°ãƒ«ãƒ¼ãƒ—'))
  * ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã—ã¦ã„ã‚‹ã¨ãã¯ï¼Ÿ
    * è¡¨ç¤ºã—ã¦æ¬²ã—ããªã„\n
      (('note:ãƒ’ãƒ³ãƒˆï¼šIO#tty?'))
  * ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã®è¡¨ç¤ºå¹…ã¯ï¼Ÿ\n
    (('note:ãƒ’ãƒ³ãƒˆï¼šio/console/size'))

= é–‹ç™ºä¾‹3

Apache Arrow\n
Red Arrow

= Apache Arrow

  * ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªãƒ¼ãƒ‡ãƒ¼ã‚¿åˆ†æç”¨\n
    ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ\n
    (('note:ã»ã¼å›ºã¾ã£ã¦ããŸ'))
  * ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªãƒ¼ãƒ‡ãƒ¼ã‚¿åˆ†æç”¨\n
    é«˜é€Ÿãªãƒ‡ãƒ¼ã‚¿æ“ä½œå®Ÿè£…\n
    (('note:å¾ã€…ã«å®Ÿè£…ãŒå§‹ã¾ã£ã¦ã„ã‚‹'))
  * ä»Šã€ã™ã”ãã‚¢ãƒ„ã„ï¼

= Apache Arrowã®ç‰¹å¾´

(('tag:center'))
(('tag:large'))
ãƒ‡ãƒ¼ã‚¿äº¤æ›ã‚³ã‚¹ãƒˆãŒä½ã„

== ã‚¹ãƒ©ã‚¤ãƒ‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ¼

: as-large-as-possible
   false

= ä½ãƒ‡ãƒ¼ã‚¿äº¤æ›ã‚³ã‚¹ãƒˆ

  * è¤‡æ•°ã‚·ã‚¹ãƒ†ãƒ ã§å”åŠ›ã—ã‚„ã™ã„
    * Rubyã§ãƒ‡ãƒ¼ã‚¿å–å¾—ğŸ ŠPythonã§åˆ†æ
  * å¾ã€…ã«Rubyã‚’ä½¿ãˆã‚‹ã¨ã“ã‚ã‚’\n
    å¢—ã‚„ã›ã‚‹

= Apache Arrowã®åˆ©ç”¨ä¾‹

  * ScalağŸ¤Python
    * (('tag:x-small'))Apache Spark
  * CPUğŸ¤GPU
    * (('tag:x-small'))((<URL:https://github.com/gpuopenanalytics/libgdf>))
  * CPUğŸ¤FPGA
    * (('tag:x-small'))((<URL:https://github.com/johanpel/fletcher>))

= Apache Arrowã‚’Rubyã§ã‚‚ï¼

  * ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’æœ¬ä½“ã§é–‹ç™º
    * æœ¬ä½“ã®é–‹ç™ºãƒãƒ¼ãƒ ã«å…¥ã£ãŸ\n
    * GObject Introspection(GI)ã‚’åˆ©ç”¨
  * GIã‚’ä½¿ã†ã¨Rubyä»¥å¤–ã®ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚‚è‡ªå‹•ç”Ÿæˆã§ãã‚‹\n
    (('note:ãƒãƒªã‚·ãƒ¼1ï¼šã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãƒ¼ã‚’è¶…ãˆã¦å”åŠ›'))

= Red Arrow

  * Apache Arrowã®\n
    Rubyãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°
  * GIãƒ™ãƒ¼ã‚¹ã®ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã«\n
    Rubyç‰¹æœ‰ã®æ©Ÿèƒ½ã‚’ãƒ—ãƒ©ã‚¹

= Rubyç‰¹æœ‰ã®æ©Ÿèƒ½ä¾‹

ã‚¹ãƒ©ã‚¤ã‚¹API

= ã‚¹ãƒ©ã‚¤ã‚¹

(('tag:center'))
ãƒ‡ãƒ¼ã‚¿ã®ä¸€éƒ¨ã‚’åˆ‡ã‚Šå‡ºã™

  # rouge ruby

  (0..10).to_a.slice(2)
  # => 2
  (0..10).to_a.slice(2..4)
  # => [2, 3, 4]
  (0..10).to_a.slice(2, 4)
  # => [2, 3, 4, 5]

= Red Arrowã®ã‚¹ãƒ©ã‚¤ã‚¹

  # rouge ruby

  table.slice(2)
  # 2è¡Œç›®ã ã‘ã®ãƒ†ãƒ¼ãƒ–ãƒ«
  # Array#sliceã¨é•ã†

= Red Arrowã®ã‚¹ãƒ©ã‚¤ã‚¹

  # rouge ruby

  table.slice(2..4)
  # 2,3,4è¡Œç›®ã ã‘ã®ãƒ†ãƒ¼ãƒ–ãƒ«
  # Array#sliceã¨åŒã˜

= Red Arrowã®ã‚¹ãƒ©ã‚¤ã‚¹

  # rouge ruby

  table.slice(2, 4)
  # 2,4è¡Œç›®ã ã‘ã®ãƒ†ãƒ¼ãƒ–ãƒ«
  # Array#sliceã¨é•ã†
  table.slice(2, 4, 6, 8)
  # 2,4,6,8è¡Œç›®ã ã‘ã®ãƒ†ãƒ¼ãƒ–ãƒ«
  # Array#sliceã¨é•ã†

= Red Arrowã®ã‚¹ãƒ©ã‚¤ã‚¹

  # rouge ruby

  table.slice([2, 4])
  # 2,3,4,5è¡Œç›®ã ã‘ã®ãƒ†ãƒ¼ãƒ–ãƒ«
  # Array#slice(2, 4)ã¨åŒã˜

= Red Arrowã®ã‚¹ãƒ©ã‚¤ã‚¹

  # rouge ruby

  table.slice([true, false] * 5)
  # 0,2,4,6,8è¡Œç›®ã ã‘ã®ãƒ†ãƒ¼ãƒ–ãƒ«

= Red Arrowã®ã‚¹ãƒ©ã‚¤ã‚¹

  # rouge ruby

  table.slice do |slicer|
    slicer.price >= 500
  end
  # priceã‚«ãƒ©ãƒ ã®å€¤ãŒ500ä»¥ä¸Šã®
  # è¡Œã ã‘ã®ãƒ†ãƒ¼ãƒ–ãƒ«

= Red Arrowã®ã‚¹ãƒ©ã‚¤ã‚¹

  # rouge ruby

  table.slice do |slicer|
    (slicer.price >= 500) &
      (slicer.is_published)
  end
  # priceã‚«ãƒ©ãƒ ã®å€¤ãŒ500ä»¥ä¸Šã‹ã¤
  # is_publishedã‚«ãƒ©ãƒ ã®å€¤ãŒtrueã®
  # è¡Œã ã‘ã®ãƒ†ãƒ¼ãƒ–ãƒ«

= Red Arrowã®ã‚¹ãƒ©ã‚¤ã‚¹

Active Recordã¿ãŸã„ãªfluent intefaceã‚ˆã‚Šã‚‚ãƒ–ãƒ­ãƒƒã‚¯å†…ã§å¼ã‚’æ›¸ãæ–¹ãŒRubyã£ã½ã„ã‚“ã˜ã‚ƒãªã„ã‹ã¨æ€ã†ã‚“ã ã‚ˆã­ãƒ¼\n
fluent interfaceã¯ORã‚’æ›¸ãã«ãã„ã‹ã‚‰ã•ãƒ¼

(('tag:xx-small'))
Fluent interface:\n
((<URL:http://bliki-ja.github.io/FluentInterface/>))

= ãƒ–ãƒ­ãƒƒã‚¯å†…ã§æ¡ä»¶å¼

  # rouge ruby

  class Arrow::Table
    # table.slice {|slicer| ...}ã®å®Ÿç¾
    def slice(*slicers)
      if block_given?
        slicer = yield(Slicer.new(self))
        slicers << slicer.evaluate
      end
      # ...
    end
  end

= ãƒ–ãƒ­ãƒƒã‚¯å†…ã§æ¡ä»¶å¼

  # rouge ruby

  class Arrow::Slicer
    def initialize(table)
      @table = table
    end

    # slicer.priceã®å®Ÿç¾
    def method_missing(name, *args, &block)
      ColumnCondition.new(@table[name])
    end
  end

= ãƒ–ãƒ­ãƒƒã‚¯å†…ã§æ¡ä»¶å¼

  # rouge ruby

  class ColumnCondition < Condition
    def initialize(column)
      @column = column
    end

    # slicer.price >= 500ã®å®Ÿç¾
    def >=(value)
      GreaterEqualCondition.new(@column, value)
    end
  end

= ãƒ–ãƒ­ãƒƒã‚¯å†…ã§æ¡ä»¶å¼

  # rouge ruby

  class GreaterEqualCondition < Condition
    def initialize(column, value)
      @column = column
      @value = value
    end

    # slicer.price >= 500ã‚’è©•ä¾¡
    def evaluate
      # ãƒ›ãƒ³ãƒˆã¯C++ã§å®Ÿè£…
      @column.collect {|value| value >= @value}
    end
  end

= ãƒ–ãƒ­ãƒƒã‚¯å†…ã§æ¡ä»¶å¼

  # rouge ruby

  class Condition
    # (slicer.price >= 500) & (...)ã®å®Ÿç¾
    def &(condition)
      AndCondition.new(self, condition)
    end
  end

= æ¡ä»¶å¼ã®ãƒã‚¤ãƒ³ãƒˆ

  * é…å»¶è©•ä¾¡
    * âŒå„è¦ç´ æ¯ã«ãƒ–ãƒ­ãƒƒã‚¯ã‚’è©•ä¾¡
    * ãƒ–ãƒ­ãƒƒã‚¯ã¯ä¸€å›ã ã‘è©•ä¾¡
    * ãƒ–ãƒ­ãƒƒã‚¯ã§æŒ‡å®šã—ãŸæ¡ä»¶ã¯\n
      ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¦C++å®Ÿè£…ã§å®Ÿè¡Œ

= Red Arrowã¨å¤–ã®ä¸–ç•Œ

  * ãƒãƒ–ã«ãªã‚‹ã¨ã„ã„ã‹ã‚‚ï¼
    * å„ç¨®ãƒ‡ãƒ¼ã‚¿ã¨å¤‰æ›å¯èƒ½ã«
    * å„ç¨®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨å¤‰æ›å¯èƒ½ã«
  * Rubyé–“ã®é€£æºã‚’æ¨é€²
    * ä»Šã¯äº’æ›æ€§ãŒãªã„ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼\n
      ğŸ Šé€£æºã§ãã‚‹ã‚ˆã†ã«ï¼

= ãƒ‡ãƒ¼ã‚¿å¤‰æ›

  * (({Arrow::Table.load}))
    * ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
  * (({Arrow::Table#save}))
    * ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãå‡ºã—

= ãƒ‡ãƒ¼ã‚¿å¤‰æ›ä¾‹

  # rouge ruby

  # CSVã‚’èª­ã¿è¾¼ã‚“ã§
  table = Arrow::Table.load("a.csv")
  # Arrowã§ä¿å­˜
  table.save("a.arrow")
  # Parquetã§ä¿å­˜
  table.save("a.parquet")

= CSVã®èª­ã¿è¾¼ã¿

  * CSVã¯åºƒãä½¿ã‚ã‚Œã¦ã„ã‚‹
    * CSVãªãƒ‡ãƒ¼ã‚¿ã‚’ç°¡å˜ã«ä½¿ãˆã‚‹ã¨æ—ã‚‹
  * é›£ã—ã„ã¨ã“ã‚
    * ãƒ‡ãƒ¼ã‚¿å®šç¾©ãŒç·©ã„\n
      ä¾‹ï¼šã‚«ãƒ©ãƒ ã®å‹æƒ…å ±ãŒãªã„

= Red Arrowã§ã®èª­ã¿è¾¼ã¿

  * 2ãƒ‘ã‚¹ã§å‡¦ç†
    (1) å…¨éƒ¨å‡¦ç†ã—ã¦å„ã‚«ãƒ©ãƒ ã®å‹ã‚’æ¨å®š
    (2) æ¨å®šã—ãŸå‹ã§Arrowã®ãƒ‡ãƒ¼ã‚¿ã«å¤‰æ›
  * ğŸ˜…æ™‚é–“ãŒã‹ã‹ã‚‹
    * èª­ã¿è¾¼ã‚“ã ãƒ‡ãƒ¼ã‚¿ã‚’åˆ¥ã®å½¢å¼ã«å¤‰æ›ã—ã¦å†åˆ©ç”¨ã™ã‚‹ä½¿ã„æ–¹ã‚’æƒ³å®š\n
      ã ã‹ã‚‰ã€ã¾ãã€ã„ã„ã‹ãªãã£ã¦

= å‹ã®æ¨å®š

  # rouge ruby

  candidate = nil
  column.each do |value|
    case value
    when nil; next # ignore
    when "true", "false", true, false; c = :boolean
    when Integer; c = :integer
    # ...
    else; c = :string # ã‚ã‹ã‚‰ãªã‹ã£ãŸã‚‰æ–‡å­—åˆ—
    end
    candidate ||= c
    candidate = :string if candidate != c # æ··ã–ã£ãŸã‚‰æ–‡å­—åˆ—
    break if candidate == :string # æ–‡å­—åˆ—ãªã‚‰çµ‚ã‚ã‚Š
  end
  candidate || :string # ã‚ã‹ã‚‰ãªã‹ã£ãŸã‚‰æ–‡å­—åˆ—

= ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå¤‰æ›

  * Numo::NArray, NMatrix
    * æ—¢å­˜ã®å¤šæ¬¡å…ƒé…åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
  * PyCallçµŒç”±ã§PyArrow
    * Rubyã§ãƒ‡ãƒ¼ã‚¿ä½œæˆğŸ ŠPythonã§å‡¦ç†
  * GDK Pixbuf
    * ç”»åƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ

= ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå¤‰æ›ä¾‹

  # rouge ruby

  # PNGç”»åƒã‚’èª­ã¿è¾¼ã¿
  pixbuf = GdkPixbuf::Pixbuf.new(file: "a.png")
  # ArrowçµŒç”±ã§Numo::NArrayã«å¤‰æ›
  narray = pixbuf.to_arrow.to_narray
  # ä¸é€æ˜ã«ï¼ˆã‚¢ãƒ«ãƒ•ã‚¡å€¤ï¼ˆé€æ˜åº¦ï¼‰ã‚’0xffã«ï¼‰
  narray[true, true, 3] = 0xff
  # ArrowçµŒç”±ã§GdkPixbuf::Pixbufã«å¤‰æ›
  no_alpha_pixbuf = narray.to_arrow.to_pixbuf
  # GIFç”»åƒã¨ã—ã¦ä¿å­˜
  no_alpha_pixbuf.save(filename: "a-no-alpha.gif")

= Pixbufâ†’Arrow

  # rouge ruby

  class GdkPixbuf::Pixbuf
    def to_arrow
      bytes = read_pixel_bytes # ãƒ”ã‚¯ã‚»ãƒ«å€¤
      buffer = Arrow::Buffer.new(bytes)
      # é«˜ã•ã€å¹…ã€ãƒãƒ£ãƒ³ãƒãƒ«æ•°ã®3æ¬¡å…ƒé…åˆ—
      # ãƒãƒ£ãƒ³ãƒãƒ«æ•°ï¼šRGBAã ã¨4ãƒãƒ£ãƒ³ãƒãƒ«
      shape = [height, width, n_channels]
      # ãƒã‚¤ãƒˆåˆ—ãªã®ã§UInt8
      Arrow::Tensor.new(Arrow::UInt8DataType.new,
                        buffer, shape)
    end
  end

= ã‚¼ãƒ­ã‚³ãƒ”ãƒ¼ã®å®Ÿç¾

  * ã‚¼ãƒ­ã‚³ãƒ”ãƒ¼
    * åŒã˜ãƒ¡ãƒ¢ãƒªãƒ¼é ˜åŸŸã‚’å‚ç…§ã—ã€\n
      ã‚³ãƒ”ãƒ¼ã›ãšã«åŒã˜ãƒ‡ãƒ¼ã‚¿ã‚’åˆ©ç”¨
    * é€Ÿã„ï¼ï¼ï¼
  * ãƒ‡ãƒ¼ã‚¿
    * ãƒã‚¤ãƒˆåˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼
    * Rubyã§ã¯(({RSTRING_PTR(string)}))

= (({String}))ã¨ã‚¼ãƒ­ã‚³ãƒ”ãƒ¼

  # rouge c

  /* pointerã®å†…å®¹ã‚’ã‚³ãƒ”ãƒ¼ */
  rb_str_new(pointer, size);
  /* pointerã®å†…å®¹ã‚’å‚ç…§ï¼šã‚¼ãƒ­ã‚³ãƒ”ãƒ¼ */
  rb_str_new_static(pointer, size);

= (({String}))ã¨ã‚¼ãƒ­ã‚³ãƒ”ãƒ¼ã¨GC

  # rouge c

  arrow_data = /* ... */;
  /* ã‚¼ãƒ­ã‚³ãƒ”ãƒ¼ */
  rb_str_new_static(arrow_data, size);
  /* arrow_dataã¯ã„ã¤ã€ã ã‚ŒãŒé–‹æ”¾ï¼Ÿ */

= Rubyã§ã‚¼ãƒ­ã‚³ãƒ”ãƒ¼

  * âŒ(({rb_str_new_static()}))ã ã‘
    * ãƒ¡ãƒ¢ãƒªãƒ¼ç®¡ç†ã§ããªã„
  * ãƒ¡ãƒ¢ãƒªãƒ¼ç®¡ç†ã™ã‚‹ä½•ã‹ãŒå¿…è¦

= Red Arrowã§ã‚¼ãƒ­ã‚³ãƒ”ãƒ¼

  * GBytesã‚’åˆ©ç”¨
  * GBytes
    * GLibæä¾›ã®ãƒã‚¤ãƒˆåˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    * ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã‚«ã‚¦ãƒ³ãƒˆã‚ã‚Š
  * Rubyã ã¨(({GLib::Bytes}))

= (({GLib::Bytes#to_s}))

  # rouge c

  static VALUE rgbytes_to_s(VALUE self) {
    GBytes *bytes = RVAL2BOXED(self, G_TYPE_BYTES);
    gsize size;
    gconstpointer data =
      g_bytes_get_data(bytes, &size);
    /* ã‚¼ãƒ­ã‚³ãƒ”ãƒ¼ã§ASCII-8BITãªæ–‡å­—åˆ—ã‚’ç”Ÿæˆ */
    VALUE rb_data = rb_enc_str_new_static(
      data, size, rb_ascii8bit_encoding());
    rb_iv_set(rb_data, "@bytes", self); /* GCå¯¾ç­– */
    return rb_data;
  }

= (({GLib::Bytes#initialize}))

  # rouge c

  static VALUE rgbytes_initialize(VALUE self, VALUE rb_data) {
    const char *pointer = RSTRING_PTR(rb_data);
    long size = RSTRING_LEN(rb_data);
    GBytes *bytes;
    if (RB_OBJ_FROZEN(rb_data)) { /* ã‚¼ãƒ­ã‚³ãƒ”ãƒ¼ */
      bytes = g_bytes_new_static(pointer, size);
      rb_iv_set(self, "source", rb_data); /* GCå¯¾ç­– */
    } else { /* ã‚³ãƒ”ãƒ¼ */
      bytes = g_bytes_new(pointer, size);
    }
    G_INITIALIZE(self, bytes);
    return Qnil;
  }

= GBytesã¯ã™ã§ã«ä½¿ã£ã¦ã„ãŸ

  # rouge ruby

  class GdkPixbuf::Pixbuf
    def to_arrow
      # ãƒ”ã‚¯ã‚»ãƒ«å€¤ã¯GLib::Bytes
      bytes = read_pixel_bytes
      buffer = Arrow::Buffer.new(bytes)
      shape = [height, width, n_channels]
      Arrow::Tensor.new(Arrow::UInt8DataType.new,
                        buffer,
                        shape)
    end
  end

= Red Chainer

(('tag:large'))
Chainerã®Rubyç§»æ¤

== ã‚¹ãƒ©ã‚¤ãƒ‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ¼

: as-large-as-possible
   false

= Chainer

  * æ·±å±¤å­¦ç¿’ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
    * Pythonã®ã¿ã§å®Ÿè£…
  * ç§»æ¤ã—ã‚„ã™ã„
    * Pythonã®ã¿ã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‹ã‚‰

= Red Chainerã‚µãƒ³ãƒ—ãƒ«

  # rouge ruby

  model = Chainer::Links::Model::Classifier.new(MLP.new(args[:unit], 10))
  optimizer = Chainer::Optimizers::Adam.new
  optimizer.setup(model)
  train, test = Chainer::Datasets::Mnist.get_mnist

  train_iter = Chainer::Iterators::SerialIterator.new(train, args[:batchsize])
  test_iter = Chainer::Iterators::SerialIterator.new(test, args[:batchsize], repeat: false, shuffle: false)

  # ...

(('tag:center'))
æ¨ªã«é•·ã„

= Chainerã®ã‚µãƒ³ãƒ—ãƒ«

  # rouge python

  import chainer
  import chainer.links as L

  model = L.Classifier(MLP(args.unit, 10))
  optimizer = chainer.optimizers.Adam()
  optimizer.setup(model)
  train, test = chainer.datasets.get_mnist()
  train_iter = chainer.iterators.SerialIterator(train, args.batchsize)
  test_iter = chainer.iterators.SerialIterator(test, args.batchsize,
                                               repeat=False, shuffle=False)

(('tag:center'))
ã“ã£ã¡ã‚‚æ¨ªã«é•·ã„

= Pythonã§ã®çŸ­ãä»•æ–¹

  # rouge python

  # é€šå¸¸
  import chainer
  model = chainer.links.Classifier(MLP(args.unit, 10))

  # Lã§ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
  import chainer.links as L
  model = L.Classifier(MLP(args.unit, 10))

= Rubyã§ã®çŸ­ãä»•æ–¹

  # rouge ruby

  # é€šå¸¸
  model = Chainer::Links::Model::Classifier.new(...)

  # Lã§ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
  L = Chainer::Links
  model = L::Model::Classifier.new(...)

= Pythonã¨Rubyã®é•ã„

  * Python
    * ãƒ•ã‚¡ã‚¤ãƒ«å†…ã§ã ã‘(({L}))ãŒæœ‰åŠ¹
    * ãƒ•ã‚¡ã‚¤ãƒ«å˜ä½ã§ãƒãƒ¼ãƒ ã‚¹ãƒšãƒ¼ã‚¹
  * Ruby
    * ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«(({L}))ãŒæœ‰åŠ¹
    * å¾®å¦™ï¼

= Rubyã‚‰ã—ãçŸ­ã

  # rouge ruby

  # Rubyã®ãƒãƒ¼ãƒ ã‚¹ãƒšãƒ¼ã‚¹ã®ä»•çµ„ã¿ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
  Module.new do
    L = Chainer::Links
    model = L::Model::Classifier.new(...)
  end

= é–‹ç™ºã—ãŸããªã£ãŸï¼Ÿ

  * æ¥½ã—ãã†ï¼
    * ä¸€ç·’ã«é–‹ç™ºã—ã‚ˆã†ãœï¼
  * ã‚„ã£ã±Rubyã§ãƒ‡ãƒ¼ã‚¿æ‰±ã„ãŸã„ï¼
    * ä¸€ç·’ã«é–‹ç™ºã—ã‚ˆã†ãœï¼
  * ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã—ãŸã„ï¼
    * ä¸€ç·’ã«é–‹ç™ºã—ã‚ˆã†ãœï¼

= ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã¸ã®é“

  * ğŸ˜…NGé›†ã‚’ãŸãã•ã‚“è¦šãˆã‚‹
  * ğŸ˜€ã‚ˆã„ã‚³ãƒ¼ãƒ‰ã«ãŸãã•ã‚“è§¦ã‚Œã‚‹

= ã‚ˆã„ã‚³ãƒ¼ãƒ‰

(('tag:large'))
Red Data Toolsã«\n
ãŸãã•ã‚“ã‚ã‚‹ï¼

== ã‚¹ãƒ©ã‚¤ãƒ‰ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ¼

: as-large-as-possible
   false

= ä¸€ç·’ã«é–‹ç™º

  * ğŸŒã©ã“ã‹ã‚‰ã§ã‚‚ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã§
    * GitHubã¨Gitterï¼ˆãƒãƒ£ãƒƒãƒˆï¼‰ã‚’ä½¿ç”¨
  * â•æ±äº¬ã¯æœˆä¸€ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã§
    * ğŸ”ã€ŒOSS Gate Red Data Toolsã€

= Join Red Data Tools!

  * Webã‚µã‚¤ãƒˆ
    * (('tag:x-small'))((<URL:https://red-data-tools.github.io/ja/>))
  * Gitterï¼ˆãƒãƒ£ãƒƒãƒˆï¼‰
    * (('tag:x-small'))((<URL:https://gitter.im/red-data-tools/ja>))
  * GitHub
    * (('tag:x-small'))((<URL:https://github.com/red-data-tools/>))
